/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  6
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#include "../input.txt"

dimensions      [0 1 -1 0 0 0 0];

internalField uniform (0 0 0);

boundaryField
{

    wall
    {
        type            noSlip;
        //value           uniform (0 0 0);
    }

    side  // outlet
    {
        type           zeroGradient;
        //type           inletOutlet;
        //inletValue     uniform (0 0 0);
    }

    frontAndBack
    {
        type            empty;
    }


	topmid  // inlet
    {
       type zeroGradient;
       //type fixedValue;
       //value uniform (0 -1e-3 0);
       //type         inletOutlet;
       //inletValue   uniform ( 0 0);
    }

    bottom
    {
        type            membraneVelocity;
        membranePermeability  $permeability;
        membranePorosity  $porosity;
        membraneWidth $thickness;
        osmoticPressure "chi";
        osmoticCoefficient $osmotic;
        solidSource "chi";
        solidConcentration "binaryReaction";
        solidModel "KozenyCarman32";
        solidBinaryReaction true;
        solidVolume $molVolume;
        writeAvg true;

        outsidePressure uniform $pp;
       // value           uniform (0 0 0);

        //  - NO LONGER NEEDED
        //type            codedFixedValue;
        // redirectType    porousMembrane;
        //
        // code
        // #{
        //
        //   const IOdictionary& tpdict =
        //     this->db().objectRegistry::
        //         lookupObject<IOdictionary>("transportProperties");
        //
        //   // initial permeability of the membrane
        //   const scalar K0(tpdict.lookupOrDefault<scalar>("membranePermeability",1e-9));
        //   // initial porosity of the membrane
        //   const scalar phi0(tpdict.lookupOrDefault<scalar>("membranePorosity",0.5));
        //   // membrane width
        //   const scalar L(tpdict.lookupOrDefault<scalar>("membraneWidth",1e-4));
        //
        //   // lookup for pressure and concentration field from the solver
        //   const GeometricField<scalar, fvPatchField, volMesh>& pfield =
        //     this->db().objectRegistry::
        //         lookupObject<GeometricField<scalar, fvPatchField, volMesh> >("p");
        //   //const GeometricField<scalar, fvPatchField, volMesh>& cfield =
        //   //  this->db().objectRegistry::
        //   //      lookupObject<GeometricField<scalar, fvPatchField, volMesh> >("c");
        //
        //   // index of this boundary
        //   label patchi=this->patch().index();
        //
        //   // concentration on the membrane surface
        //   //const fvPatchScalarField& cc(cfield.boundaryField()[patchi]);
        //
        //   // solid concentration on the surface
        //   //const dynamicRetentionFvPatchScalarField& Cpr
        //   //(
        //   //  refCast<const dynamicRetentionFvPatchScalarField>(cc)
        //   //);
        //
        //   // porosity ratio
        //   //const scalarField phir((phi0-Cpr.S())/phi0);
        //   // 1-porosity ratio
        //   //const scalarField psir((scalar(1)-phi0+Cpr.S())/(scalar(1)-phi0));
        //
        //   // compute permeability of the membrane
        //   vector K
        //                 (
        //                   vector(0,K0/L,0) //* pow(phir,2)/pow(psir,3)
        //                 );
        //
        //   //Info << "Average permeability " << gSum(K)/K.size() << endl;
        //
        //   // set outlet velocity through the membrane
        //   // assuming the pressure outside is p=0
        //   operator==( - K*(pfield.boundaryField()[patchi]) );
        //             //-K & gradp.boundaryField()[patchi]
        // #};
        // codeInclude
        // #{
        //     #include "fvCFD.H"
        //     //#include "dynamicRetentionFvPatchScalarField.H"
        // #};
        //
        // codeOptions
        // #{
        //     -I$(LIB_SRC)/finiteVolume/lnInclude -I$(LIB_SRC)/meshTools/lnInclude
        // #};

    }
}


// ************************************************************************* //
